
[[ CHAIN OF CUSTODY ]]


User
  ↓ (issue.intent envelope)
Mirage
  ↓ (command envelope)
Ghost
  ↓ (seed.execute envelope)
Seed
  ↑ (seed.result envelope)
Ghost
  ↑ (event envelope)
Mirage
  ↑ (report envelope)
User


[[ protocol ]]        # Wire-level contract for all control-plane communication
metadata = [
	name = "EdgeCTL Control Plane Protocol",
	version = "v1",
	transport = "stream-oriented (transport agnostic)",
	encoding = "binary fixed-header + optional auth + flat TLV",
	compatibility = "unknown fields ignored; unknown flags ignored"
]
header = [
	magic = "uint32",
	version = "uint16",
	header_len = "uint16",
	message_id = "uint64",
	message_type = "uint32",
	flags = "uint32",
	payload_len = "uint64"
]
flags = [
	has_auth = "0x01",
	is_response = "0x02",
	is_error = "0x04"
]
tlv = [
	field_id = "uint16",
	type = "uint8",
	length = "uint32",
	value = "[]byte"
]


[[ boundaries ]]      # Protocol interface boundaries (authority + direction)
links = [
	user_to_mirage = "issue(intent)  [desired-state authority enters system]",
	mirage_to_ghost = "command(imperative)  [execution delegated]",
	ghost_to_seed = "seed.execute(concrete operation)  [state mutation requested]",
	seed_to_ghost = "seed.result(raw execution output)  [execution observation]",
	ghost_to_mirage = "event(observed state delta)  [controller feedback]",
	mirage_to_user = "report(reconciled status)  [external visibility]"
]


[[ envelopes ]]       # Semantic envelope types over shared wire format
definitions = [
	issue = "User intent accepted by Mirage; source of desired state",
	command = "Mirage instruction for a Ghost-scoped action",
	seed_execute = "Ghost instruction for Seed command execution",
	seed_result = "Seed execution output returned to Ghost",
	event = "Ghost observation emitted to Mirage",
	report = "Mirage summary emitted to user"
]
required_fields = [
	issue = "intent_id, actor, target_scope, objective",
	command = "command_id, intent_id, ghost_id, seed_selector, operation",
	seed_execute = "execution_id, command_id, seed_id, operation, args",
	seed_result = "execution_id, seed_id, status, stdout, stderr, exit_code",
	event = "event_id, command_id, intent_id, ghost_id, seed_id, outcome",
	report = "intent_id, phase, summary, completion_state"
]


[[ packaging ]]       # Code/package ownership boundaries
packages = [
	pkg_protocol = "internal/protocol  (wire format, codec, semantic parsing primitives)",
	pkg_mirage = "internal/mirage  (orchestration layer: intent ingest, reconcile, report)",
	pkg_ghost = "internal/ghost  (execution layer: command routing, seed dispatch, event emission)",
	pkg_seed_interfaces = "internal/seeds  (seed service interfaces provided by ghosts)",
	pkg_cmd_mirage = "cmd/miragectl  (mirage server runtime entrypoint)",
	pkg_cmd_ghost = "cmd/ghostctl  (ghost server runtime entrypoint)"
]
ownership = [
	wire_contract = "owned by protocol package",
	orchestration = "owned by mirage (intent, reconcile, reporting)",
	execution = "owned by ghosts (command handling, seed invocation, event emission)",
	service_interfaces = "owned by seeds provided by ghosts",
	observed_state = "owned by mirage (aggregated from ghost events)"
]


[[ EXAMPLES ]]


[[ issue ]]           # User -> Mirage
fields = [
	message_type = "Intent",
	intent_id = "intent.2026.02.06.001",
	actor = "user:dan",
	target_scope = "ghost:edge-ctl/*",
	objective = "restart service.mongodb"
]


[[ command ]]         # Mirage -> Ghost
fields = [
	message_type = "Command",
	command_id = "cmd.2026.02.06.001",
	intent_id = "intent.2026.02.06.001",
	ghost_id = "ghost.edge-ctl",
	seed_selector = "service.mongodb",
	operation = "mongo_restart"
]


[[ event ]]           # Ghost -> Mirage
fields = [
	message_type = "Event",
	event_id = "evt.2026.02.06.001",
	command_id = "cmd.2026.02.06.001",
	intent_id = "intent.2026.02.06.001",
	ghost_id = "ghost.edge-ctl",
	seed_id = "service.mongodb",
	outcome = "success"
]


[[ DESCRIPTION ]]


[[ PROTOCOL BOUNDARY — CANONICAL LOOP ]]

----------------------------------------
STEP 1: ISSUE (User -> Mirage)
----------------------------------------

user   |> issue(intent)
mirage <| issue {user}           # Persist desired state


----------------------------------------
STEP 2: RECONCILE (Mirage)
----------------------------------------

mirage <|> reconcile
mirage |> command {ghostZ}


----------------------------------------
STEP 3: EXECUTE (Ghost -> Seed)
----------------------------------------

ghostZ <| command {mirage}
ghostZ <|> reconcile
ghostZ |> seed.execute {seedX}
seedX  |> seed.result {ghostZ}


----------------------------------------
STEP 4: OBSERVE (Ghost -> Mirage)
----------------------------------------

ghostZ |> event {mirage}
mirage <| event {ghostZ}


----------------------------------------
STEP 5: REPORT (Mirage -> User)
----------------------------------------

mirage |> report {user}

# Outcomes:
# - report.satisfied    -> no further command required
# - report.in_progress  -> additional commands scheduled
# - report.corrective   -> drift detected, corrective commands scheduled

# Loop continues while intent remains active.
